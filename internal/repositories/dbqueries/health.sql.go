// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: health.sql

package dbqueries

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getHeartRatesByUserAndDateRange = `-- name: GetHeartRatesByUserAndDateRange :many
SELECT id, user_id, device_id, bpm, created_at FROM "HEART_RATES"
WHERE user_id = $1 AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
`

type GetHeartRatesByUserAndDateRangeParams struct {
	UserID      uuid.UUID
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

func (q *Queries) GetHeartRatesByUserAndDateRange(ctx context.Context, arg GetHeartRatesByUserAndDateRangeParams) ([]HEARTRATE, error) {
	rows, err := q.db.Query(ctx, getHeartRatesByUserAndDateRange, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HEARTRATE
	for rows.Next() {
		var i HEARTRATE
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.Bpm,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleepsByUserAndDateRange = `-- name: GetSleepsByUserAndDateRange :many
SELECT id, user_id, device_id, started_at, ended_at FROM "SLEEPS"
WHERE user_id = $1 AND started_at BETWEEN $2 AND $3
ORDER BY started_at DESC
`

type GetSleepsByUserAndDateRangeParams struct {
	UserID      uuid.UUID
	StartedAt   time.Time
	StartedAt_2 time.Time
}

func (q *Queries) GetSleepsByUserAndDateRange(ctx context.Context, arg GetSleepsByUserAndDateRangeParams) ([]SLEEP, error) {
	rows, err := q.db.Query(ctx, getSleepsByUserAndDateRange, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SLEEP
	for rows.Next() {
		var i SLEEP
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStepsByUserAndDateRange = `-- name: GetStepsByUserAndDateRange :many
SELECT id, user_id, device_id, step_count, created_at FROM "STEPS"
WHERE user_id = $1 AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
`

type GetStepsByUserAndDateRangeParams struct {
	UserID      uuid.UUID
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

func (q *Queries) GetStepsByUserAndDateRange(ctx context.Context, arg GetStepsByUserAndDateRangeParams) ([]STEP, error) {
	rows, err := q.db.Query(ctx, getStepsByUserAndDateRange, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []STEP
	for rows.Next() {
		var i STEP
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.StepCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemperaturesByUserAndDateRange = `-- name: GetTemperaturesByUserAndDateRange :many
SELECT id, user_id, device_id, temperature_celsius, created_at FROM "TEMPERATURES"
WHERE user_id = $1 AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
`

type GetTemperaturesByUserAndDateRangeParams struct {
	UserID      uuid.UUID
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

func (q *Queries) GetTemperaturesByUserAndDateRange(ctx context.Context, arg GetTemperaturesByUserAndDateRangeParams) ([]TEMPERATURE, error) {
	rows, err := q.db.Query(ctx, getTemperaturesByUserAndDateRange, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TEMPERATURE
	for rows.Next() {
		var i TEMPERATURE
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.TemperatureCelsius,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeightsByUserAndDateRange = `-- name: GetWeightsByUserAndDateRange :many
SELECT id, user_id, device_id, weight_kg, created_at FROM "WEIGHTS"
WHERE user_id = $1 AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
`

type GetWeightsByUserAndDateRangeParams struct {
	UserID      uuid.UUID
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

func (q *Queries) GetWeightsByUserAndDateRange(ctx context.Context, arg GetWeightsByUserAndDateRangeParams) ([]WEIGHT, error) {
	rows, err := q.db.Query(ctx, getWeightsByUserAndDateRange, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WEIGHT
	for rows.Next() {
		var i WEIGHT
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.WeightKg,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertHeartRate = `-- name: InsertHeartRate :one
INSERT INTO "HEART_RATES" (id, user_id, device_id, bpm, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, device_id, bpm, created_at
`

type InsertHeartRateParams struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	DeviceID  uuid.UUID
	Bpm       int32
	CreatedAt time.Time
}

// HEART RATE QUERIES
func (q *Queries) InsertHeartRate(ctx context.Context, arg InsertHeartRateParams) (HEARTRATE, error) {
	row := q.db.QueryRow(ctx, insertHeartRate,
		arg.ID,
		arg.UserID,
		arg.DeviceID,
		arg.Bpm,
		arg.CreatedAt,
	)
	var i HEARTRATE
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.Bpm,
		&i.CreatedAt,
	)
	return i, err
}

const insertHeartRates = `-- name: InsertHeartRates :exec
INSERT INTO "HEART_RATES" (id, user_id, device_id, bpm, created_at)
SELECT UNNEST($1::uuid[]), UNNEST($2::uuid[]), UNNEST($3::uuid[]), UNNEST($4::integer[]), UNNEST($5::timestamptz[])
`

type InsertHeartRatesParams struct {
	Column1 []uuid.UUID
	Column2 []uuid.UUID
	Column3 []uuid.UUID
	Column4 []int32
	Column5 []time.Time
}

func (q *Queries) InsertHeartRates(ctx context.Context, arg InsertHeartRatesParams) error {
	_, err := q.db.Exec(ctx, insertHeartRates,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const insertSleep = `-- name: InsertSleep :one
INSERT INTO "SLEEPS" (id, user_id, device_id, started_at, ended_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, device_id, started_at, ended_at
`

type InsertSleepParams struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	DeviceID  uuid.UUID
	StartedAt time.Time
	EndedAt   time.Time
}

// SLEEP QUERIES
func (q *Queries) InsertSleep(ctx context.Context, arg InsertSleepParams) (SLEEP, error) {
	row := q.db.QueryRow(ctx, insertSleep,
		arg.ID,
		arg.UserID,
		arg.DeviceID,
		arg.StartedAt,
		arg.EndedAt,
	)
	var i SLEEP
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const insertSleeps = `-- name: InsertSleeps :exec
INSERT INTO "SLEEPS" (id, user_id, device_id, started_at, ended_at)
SELECT UNNEST($1::uuid[]), UNNEST($2::uuid[]), UNNEST($3::uuid[]), UNNEST($4::timestamptz[]), UNNEST($5::timestamptz[])
`

type InsertSleepsParams struct {
	Column1 []uuid.UUID
	Column2 []uuid.UUID
	Column3 []uuid.UUID
	Column4 []time.Time
	Column5 []time.Time
}

func (q *Queries) InsertSleeps(ctx context.Context, arg InsertSleepsParams) error {
	_, err := q.db.Exec(ctx, insertSleeps,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const insertStep = `-- name: InsertStep :one
INSERT INTO "STEPS" (id, user_id, device_id, step_count, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, device_id, step_count, created_at
`

type InsertStepParams struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	DeviceID  uuid.UUID
	StepCount int32
	CreatedAt time.Time
}

// STEP QUERIES
func (q *Queries) InsertStep(ctx context.Context, arg InsertStepParams) (STEP, error) {
	row := q.db.QueryRow(ctx, insertStep,
		arg.ID,
		arg.UserID,
		arg.DeviceID,
		arg.StepCount,
		arg.CreatedAt,
	)
	var i STEP
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.StepCount,
		&i.CreatedAt,
	)
	return i, err
}

const insertSteps = `-- name: InsertSteps :exec
INSERT INTO "STEPS" (id, user_id, device_id, step_count, created_at)
SELECT UNNEST($1::uuid[]), UNNEST($2::uuid[]), UNNEST($3::uuid[]), UNNEST($4::integer[]), UNNEST($5::timestamptz[])
`

type InsertStepsParams struct {
	Column1 []uuid.UUID
	Column2 []uuid.UUID
	Column3 []uuid.UUID
	Column4 []int32
	Column5 []time.Time
}

func (q *Queries) InsertSteps(ctx context.Context, arg InsertStepsParams) error {
	_, err := q.db.Exec(ctx, insertSteps,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const insertTemperature = `-- name: InsertTemperature :one
INSERT INTO "TEMPERATURES" (id, user_id, device_id, temperature_celsius, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, device_id, temperature_celsius, created_at
`

type InsertTemperatureParams struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	DeviceID           uuid.UUID
	TemperatureCelsius float64
	CreatedAt          time.Time
}

// TEMPERATURE QUERIES
func (q *Queries) InsertTemperature(ctx context.Context, arg InsertTemperatureParams) (TEMPERATURE, error) {
	row := q.db.QueryRow(ctx, insertTemperature,
		arg.ID,
		arg.UserID,
		arg.DeviceID,
		arg.TemperatureCelsius,
		arg.CreatedAt,
	)
	var i TEMPERATURE
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.TemperatureCelsius,
		&i.CreatedAt,
	)
	return i, err
}

const insertTemperatures = `-- name: InsertTemperatures :exec
INSERT INTO "TEMPERATURES" (id, user_id, device_id, temperature_celsius, created_at)
SELECT UNNEST($1::uuid[]), UNNEST($2::uuid[]), UNNEST($3::uuid[]), UNNEST($4::float[]), UNNEST($5::timestamptz[])
`

type InsertTemperaturesParams struct {
	Column1 []uuid.UUID
	Column2 []uuid.UUID
	Column3 []uuid.UUID
	Column4 []float64
	Column5 []time.Time
}

func (q *Queries) InsertTemperatures(ctx context.Context, arg InsertTemperaturesParams) error {
	_, err := q.db.Exec(ctx, insertTemperatures,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const insertWeight = `-- name: InsertWeight :one
INSERT INTO "WEIGHTS" (id, user_id, device_id, weight_kg, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, device_id, weight_kg, created_at
`

type InsertWeightParams struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	DeviceID  uuid.UUID
	WeightKg  float64
	CreatedAt time.Time
}

// WEIGHT QUERIES
func (q *Queries) InsertWeight(ctx context.Context, arg InsertWeightParams) (WEIGHT, error) {
	row := q.db.QueryRow(ctx, insertWeight,
		arg.ID,
		arg.UserID,
		arg.DeviceID,
		arg.WeightKg,
		arg.CreatedAt,
	)
	var i WEIGHT
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.WeightKg,
		&i.CreatedAt,
	)
	return i, err
}

const insertWeights = `-- name: InsertWeights :exec
INSERT INTO "WEIGHTS" (id, user_id, device_id, weight_kg, created_at)
SELECT UNNEST($1::uuid[]), UNNEST($2::uuid[]), UNNEST($3::uuid[]), UNNEST($4::float[]), UNNEST($5::timestamptz[])
`

type InsertWeightsParams struct {
	Column1 []uuid.UUID
	Column2 []uuid.UUID
	Column3 []uuid.UUID
	Column4 []float64
	Column5 []time.Time
}

func (q *Queries) InsertWeights(ctx context.Context, arg InsertWeightsParams) error {
	_, err := q.db.Exec(ctx, insertWeights,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}
